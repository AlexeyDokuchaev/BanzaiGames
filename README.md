# BanzaiGames test

*исполнитель: Алексей Докучаев*

---
### Какакие принцыпы SOLID нарушены в проектировании сервиса отправки уведомлений?
- SRP: The Single Responsibility Principle

Ф-ция notify зависит от 2х сущностей (smsNotificator & emailNotificator) и будет подвергаться
измененю при изменении любой из этих сущностей, а так же любой из далее добавленных. 

- OCP: The Open Closed Principle

В данном примере все противоречит OCP, никаких абстракций, полиморфизма, реализаций.
 Никакого расширения. Только композиция, только хардкор \m/
 
- LSP: The Liskov Substitution Principle

Опять же в примере нет ни наследования ни реализации, объекты не взаимозаменяемы и при добавлении
нового придется менять много мест использования.

- ISP: The Interface Segregation Principle

нет интерфейса - нет проблемы. 

- DIP: The Dependency Inversion Principle

В данном примере нет абстракций, что уже нарушает принцип, но конкретнее, высокоуровневый компонент 
NotificationService а конкретнее его ф-ционал notify зависит от низкоуровневого User.
---
### Какие паттерны проектирования можно использовать, чтобы сделать сервис более гибким и способным к легкому расширению способов рассылки

Я использовал несколько паттерном:
- Адаптер 

нужен при условии невозможности реализации классом User интерфейса Recipient, а для гибкого расширения
мы должны избавиться от конкретики и перейти на абстракции, в этом поможет агрегация и интерфейсы. 
Так же это решир несколько проблем нарушения принципов SOLID

- Стратегия

позволит нам легко и быстро добавлять новые способы отправки нотификаций

---
### Какие еще проблемы есть в этом коде?

В данном примере очень все астрактно, на реальном примере может быть совсем разные вариции
 реализации внутри и сильно придераться к этому коду получается так же абстрактно.
 
1. В классах нотификаторах отсутствует строгая типизация аргументов ф-ций
1. Нет никаких проверок и обработки исключений
1. Отсутствуют возвращаемые значения
1. Код совсем не гибкий
1. Но большинство проблем это проблемы архитектуры

---
##PS
- Принципы SOLID хороши тем, что их использовать не обязательно, в плане если реализация ISP несет
оверхед больший чем выхлоп от него, то мы можем опустить его использование ради более простой
и понятной структуры кода. Даже в данном примере из 4х классов выросло 8 и 3 интерфейса. 

- Паттерны проектирования хороши на новой проекте/модуле где их внедрение не стоит ничего,
но закладывает большой потенциал для расширения. Зачастую в легаси проекте внедрение паттерна
обойдется так же как переписать весь модуль применения этого паттерна, а то и дороже.

В общем я считаю что уметь и знать принципы и фишки очень хорошо, но упарываться в них
это не всегда благо.

###PSS

В коммитах описывал что и для чего делаю.